using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace source_generator;

[Generator]
public class AutoPropertyGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(SetDefault);
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    private void SetDefault(GeneratorPostInitializationContext contex)
    {
        const string AttributeText = @"using System;
namespace Pancake.SourceGenerator
{
    [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
    sealed class AutoPropertyAttribute : Attribute
    {
        public Type Type { get; set; }
        public AccessModifier Access { get; set; }

        public AutoPropertyAttribute(AccessModifier access = AccessModifier.PublicGet)
        {
            Access = access;
        }

        public AutoPropertyAttribute(Type type, AccessModifier access = AccessModifier.PublicGet)
        {
            Type = type;
            Access = access;
        }
    }

    [Flags]
    public enum AccessModifier
    {
        PublicGet = 1,
        PublicGetSet = 1 << 1,
        PublicGetPrivateSet = 1 << 2,
        PrivateGet = 1 << 3,
        PrivateGetSet = 1 << 4,
        ProtectedGet = 1 << 5,
        ProtectedGetSet = 1 << 6,
        ProtectedGetPrivateSet = 1 << 7,
        InternalGet = 1 << 8,
        InternalGetSet = 1 << 9,
        InternalGetPrivateSet = 1 << 10,
        ProtectedInternalGet = 1 << 11,
        ProtectedInternalGetSet = 1 << 12,
        ProtectedInternalGetPrivateSet = 1 << 13,
    }
}";
        
        contex.AddSource("AutoProperty.Generated.cs", SourceText.From(AttributeText, Encoding.UTF8));
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var receiver = context.SyntaxReceiver as SyntaxReceiver;
        if (receiver == null) return;

        var fieldSymbols = new List<(IFieldSymbol field, ITypeSymbol sourceType, ITypeSymbol targetType, AccessModifier access)>();

        foreach (var field in receiver.TargetFields)
        {
            var model = context.Compilation.GetSemanticModel(field.field.SyntaxTree);
            foreach (var variable in field.field.Declaration.Variables)
            {
                var fieldSymbol = model.GetDeclaredSymbol(variable) as IFieldSymbol;

                var arguments = field.syntax.ArgumentList?.Arguments;
                (IFieldSymbol field, ITypeSymbol sourceType, ITypeSymbol targetType, AccessModifier access) result = (fieldSymbol, fieldSymbol.Type, fieldSymbol.Type,
                    AccessModifier.PublicGet);
                if (arguments.HasValue)
                {
                    foreach (var argument in arguments)
                    {
                        var expr = argument.Expression;

                        if (expr is TypeOfExpressionSyntax typeOfExpr)
                        {
                            var typeSymbol = model.GetSymbolInfo(typeOfExpr.Type).Symbol as ITypeSymbol;
                            result.targetType = typeSymbol;
                        }
                        //if (argument.NameEquals?.Name.Identifier.Text == "access")
                        else
                        {
                            var parsed = Enum.ToObject(typeof(AccessModifier), model.GetConstantValue(expr).Value);
                            result.access = (AccessModifier) parsed;
                        }
                    }
                }

                fieldSymbols.Add(result);
            }
        }

        foreach (var group in fieldSymbols.GroupBy(field => field.field.ContainingType))
        {
            var classSource = ProcessClass(group.Key, group.ToList());
            context.AddSource($"{group.Key.Name}.Generated.cs", SourceText.From(classSource, Encoding.UTF8));
        }
    }

    private string ProcessClass(
        INamedTypeSymbol classSymbol,
        List<(IFieldSymbol field, ITypeSymbol sourceType, ITypeSymbol targetType, AccessModifier acess)> fieldSymbols)
    {
        var classAccessiblity = classSymbol.DeclaredAccessibility.ToString().ToLower();
        var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace ? "" : $"namespace {classSymbol.ContainingNamespace.ToDisplayString()}\n{{\n";
        var classDeclaration = $@"
    // This class is generated by AutoPropertyGenerator.
    {classAccessiblity} partial class {classSymbol.Name}
    {{
";

        var builder = new StringBuilder();
        builder.Append(namespaceName);
        builder.Append(classDeclaration);

        foreach (var (field, sourceType, targetType, acess) in fieldSymbols)
        {
            var className = targetType.ToDisplayString();
            var sourceClassName = sourceType.ToDisplayString();
            var propertyName = GetPropertyName(field.Name);
            bool typeIsSame = className == sourceClassName;

            switch (acess)
            {
                case AccessModifier.PrivateGet:
                case AccessModifier.PrivateGetSet:
                    builder.Append($@"
        private {className} {propertyName}
        {{
            get
            {{");
                    break;
                case AccessModifier.PublicGet:
                case AccessModifier.PublicGetSet:
                case AccessModifier.PublicGetPrivateSet:
                    builder.Append($@"
        public {className} {propertyName}
        {{
            get
            {{");
                    break;
                case AccessModifier.ProtectedGet:
                case AccessModifier.ProtectedGetSet:
                case AccessModifier.ProtectedGetPrivateSet:
                    builder.Append($@"
        protected {className} {propertyName}
        {{
            get
            {{");
                    break;
                case AccessModifier.InternalGet:
                case AccessModifier.InternalGetSet:
                case AccessModifier.InternalGetPrivateSet:
                    builder.Append($@"
        internal {className} {propertyName}
        {{
            get
            {{");
                    break;
                case AccessModifier.ProtectedInternalGet:
                case AccessModifier.ProtectedInternalGetSet:
                case AccessModifier.ProtectedInternalGetPrivateSet:
                    builder.Append($@"
        protected internal {className} {propertyName}
        {{
            get
            {{");
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            if (typeIsSame)
            {
                builder.Append($@"
                return this.{field.Name};
            }}");
            }
            else
            {
                builder.Append($@"
            return ({className})this.{field.Name};
            }}");
            }


            switch (acess)
            {
                case AccessModifier.PrivateGetSet:
                case AccessModifier.ProtectedGetSet:
                case AccessModifier.PublicGetSet:
                case AccessModifier.InternalGetSet:
                case AccessModifier.ProtectedInternalGetSet:
                    builder.Append($@"
            set
            {{");
                    if (typeIsSame)
                    {
                        builder.Append($@"
                this.{field.Name} = value;
            }}");
                    }
                    else
                    {
                        builder.Append($@"
                this.{field.Name} = ({sourceClassName})value;
            }}");
                    }

                    break;

                case AccessModifier.PublicGetPrivateSet:
                case AccessModifier.ProtectedGetPrivateSet:
                case AccessModifier.InternalGetPrivateSet:
                case AccessModifier.ProtectedInternalGetPrivateSet:
                    builder.Append($@"
            private set
            {{");
                    if (typeIsSame)
                    {
                        builder.Append($@"
                this.{field.Name} = value;
            }}");
                    }
                    else
                    {
                        builder.Append($@"
                this.{field.Name} = ({sourceClassName})value;
            }}");
                    }

                    break;
            }

            builder.Append($@"
        }}
");
        }


        builder.Append(@"
    }"); // Close class
        if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            builder.Append(@"
}"); // Close namespace
        }

        return builder.ToString();
    }

    private string GetPropertyName(string fieldName)
    {
        for (int i = 0; i < fieldName.Length; i++)
        {
            if (char.IsLower(fieldName[i]))
            {
                return char.ToUpper(fieldName[i]) + fieldName.Substring(i + 1);
            }
        }

        return "NoLetterCanUppercase";
    }

    private (bool Implicit, bool Explicit) CheckConversionInType(ITypeSymbol typeToCheck, ITypeSymbol targetType)
    {
        (bool Implicit, bool Explicit) result = (false, false);

        foreach (var member in typeToCheck.GetMembers())
        {
            if (member is IMethodSymbol methodSymbol && methodSymbol.MethodKind == MethodKind.Conversion &&
                methodSymbol.ReturnType.Equals(targetType, SymbolEqualityComparer.Default))
            {
                if (methodSymbol.IsImplicitlyDeclared)
                    result.Implicit = true;
                else
                    result.Explicit = true;
            }
        }

        return result;
    }
}